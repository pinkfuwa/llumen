llumen is a LLM chat web-application. featuring three mode: normal chat, search and deep research.

# Structure

llumen follow mono repo file structure:
* `./frontend`: svelte 5(static-adapter) frontend
* `./backend`: axum backend
* `./agent`: prompt and regression prompt test
* `./package`: build script and deployment declaration
* `./docs`: document.

# Strong Size Awareness

Our project emphasizes performance and binary-size. We choose minimal dependency for both frontend and backend.

# Rust coding guidelines

* Prioritize code correctness and clarity. Speed and efficiency are secondary priorities unless otherwise specified.
* Do not write organizational or comments that summarize the code. Comments should only be written in order to explain "why" the code is written in some way in the case there is a reason that is tricky / non-obvious.
* Prefer implementing functionality in existing files unless it is a new logical component. Avoid creating many small files.
* Avoid using functions that panic like `unwrap()`, instead use mechanisms like `?` to propagate errors.
* Be careful with operations like indexing which may panic if the indexes are out of bounds.
* Never silently discard errors with `let _ =` on fallible operations. Always handle errors appropriately:
  - Propagate errors with `?` when the calling function should handle them
  - Use `.log_err()` or similar when you need to ignore errors but want visibility
  - Use explicit error handling with `match` or `if let Err(...)` when you need custom logic
  - For error cause by user's bad request body, send the rrror by return `Json<Error>`
  Example:
  ```rust
  pub trait WithKind<T> {
      fn kind(self, kind: ErrorKind) -> Result<T, Json<Error>>;
      fn raw_kind(self, kind: ErrorKind) -> Result<T, Error>;
  }
  impl<T, E> WithKind<T> for Result<T, E>;
  ```
  - For error cause by false output of LLM, place insert chunk to top-level message.
* Never create files with `mod.rs` paths - prefer `src/some_module.rs` instead of `src/some_module/mod.rs`.
* Use full words for variable names (no abbreviations like "q" for "queue")
* Always use `cargo add` to add new dependency, which should automatically chose latest version
* Use variable shadowing to scope clones in async contexts for clarity, minimizing the lifetime of borrowed references.
  Example:
  ```rust
  executor.spawn({
      let task_ran = task_ran.clone();
      async move {
          *task_ran.borrow_mut() = true;
      }
  });
  ```
* Always follow separation of concerns principle

# general coding guidelines

## Use correct tools

* Always use pnpm instead of npm
* Always use just for scripting system(called by developer)
* Always use plain bash script in `packages` for build script

## Conventional Commits

The Conventional Commits specification is a lightweight convention on top of commit messages. The commit message should be structured as follows:
```
<type>: <description>

[optional body]

[optional footer(s)]
[BREAKING CHANGE: `function_name` changed]
```

## Separation of Concerns

* Place UI and presentation logic in frontend/src/lib/ui (components, view helpers, styles). Keep this folder as the single place for UI-specific utilities and components.
* For Svelte components and frontend logic, prefer placing UI-only helpers, components, and styles under frontend/src/lib/ui to keep presentation concerns isolated.
* Keep route handlers in backend/src/routes and limit them to high-level request/response orchestration and input validation; routes should be thin.
* Put business/domain logic and data access into backend/src/lib (services, use-cases, repositories) so routes remain thin and reusable.
* Avoid mixing UI, business, and persistence code across layers; prefer clear module boundaries and single-responsibility functions.

## Always check before commit

* If backend changed, run `cargo check` and `cargo test`.
* If frontend changed, run `pnpm check` and `pnpm test`.
* If very complex logic changed, check `.github/workflows/check.yml` and try pass all CI tests.
* If dependency changed, regenerate third-party licenses by `pnpm run generate-licenses` in frontend and `cargo bundle-licenses --format toml` in backend.
* `pnpm build`, `cargo build` and `cargo test --release` is usually unnecessary.

## Database government

We use sea-orm without entity-codegen. When modifying migration files, ensure they are compatible with the current database schema. don't generate entity-codegen.

## Agent and subagent

There are three agent: normal/search/deep-research

The **subagent pattern** is the superset of simple tool for handling complex, multi-step tasks in LLM applications.

To create new subagent:
1. Define a tool in `get_tools` with a unique name and schema.
2. On tool call, invoke `handoff_tool`, passing the pipeline and tool arguments.
3. Use mutable `CompletionContext` for all state updates.
4. On error, append an **error chunk** to the assistant output.
5. When sub-agent finished its job, return ture is agent take the final output, or return false to trigger next completion(common pattern for simple tool call).
6. create/modify agent to wire subagent to agent

# Svelte 5 coding guidelines

* Prioritize declarative code and reactivity clarity using Svelte 5 runes.
* Do not write comments that merely summarize code. Use them only to explain non-obvious "why" decisions, such as workarounds for edge cases.
* Prefer extending existing components unless introducing a new logical unit (e.g., a distinct UI module). Avoid proliferating small, single-purpose components; consolidate where logical.
* Embrace runes for state management: Use `$state` for mutable state, `$derived` for computed values, and `$effect` for side effects. Avoid Svelte 4-style reactivity patterns like `{@const}` or legacy bindings.
* Use full descriptive names for variables and props (e.g., `userProfile` instead of `up`). Follow camelCase for JS variables and kebab-case for component names/props.
* Always use **typescript**, and Never use `any` type
* For shared state across components, prefer lightweight stores (`writable` or `readable`) only when necessary (e.g., app-wide data). Otherwise, use props and runes for local reactivity to minimize global dependencies.
* Handle asynchronous operations declaratively with custom query management library.
* Never ignore errors; use effects or snippets, and expose user-friendly feedback via components.
  - Propagate critical errors (backend disconnect/reachable) with `dispatchError` from `frontend/src/lib/error.ts`.
  - For user-input errors (e.g., form validation), display inline messages without crashing the app.
* `$effect` should be called during component initialization, `$state` should be at top-level(function...)
* Runes should be used in svelte or svelte.ts file
* Prefer using arrow function for callback(onclick/onpaste/...)

## Query Management Library

`frontend/src/lib/api/state/index.ts` emphasizes small bundle sizes by omitting advanced features like automatic deduplication in queries and signal-based inputs.

Following are step to connect new endpoint:
1. run codegen to generate typescript type from rust code.
2. Create file for corresponding resource type in `frontend/src/lib/api/<resource>(.svelte).ts`
3. use custom query management library
  ```ts
  export function getUsers(): UserListResp | undefined {
  	return users;
  }
  export function useUsersQueryEffect() {
  	createQueryEffect<Record<string, never>, UserListResp>({
  		path: 'user/list',
  		body: {},
  		updateData: (data) => {
  			users = data;
  		}
  	});
  }
  ```
4. call the function just created inside reactivity context(must be called during component initialization)

# Tech Stack

* Rust
* Axum
* SeaORM
* Tokio
* mLua with luau sandboxing
* typeshare(codegen)
* Svelte 5(SPA)
* TailwindCSS
* Vite
* TypeScript
* bit-ui
* lezer(for markdown parsing)

# Keep document in sync

* document user-facing changes in `docs/user/`
* document architecture changes in `docs/dev/`
