---
title: "Architecture"
description: "How llumen is built"
---

## Overview

Llumen follows a modern, minimal architecture:

```
┌─────────────┐
│   Browser   │
└──────┬──────┘
       │ HTTP/SSE
┌──────▼──────────┐
│  Svelte 5 SPA   │ (Static)
└──────┬──────────┘
       │ API Calls
┌──────▼──────────┐
│  Axum Backend   │ (Rust)
└──────┬──────────┘
       │
┌──────▼──────────┐
│  LLM API        │ (OpenRouter/OpenAI/Local)
└─────────────────┘
```

## Technology Stack

### Backend
- **Language:** Rust (MSRV 1.89)
- **Framework:** Axum (lightweight, async)
- **Runtime:** Tokio (async runtime)
- **Serialization:** serde_json

### Frontend
- **Framework:** Svelte 5
- **Build:** Vite
- **Adapter:** static-adapter (pre-rendered)
- **Styling:** Custom CSS (no framework)

### Deployment
- **Container:** Docker (multi-stage build)
- **Binary:** Single executable (~17MB)
- **Storage:** File system (SQLite for users)

## Design Principles

### 1. Minimal Dependencies

**Why:** Security, size, compile time

**How:**
- Carefully evaluate each dependency
- Prefer standard library when possible
- Avoid heavy frameworks

### 2. Performance First

**Why:** Run on modest hardware

**How:**
- Rust for backend (memory safe, fast)
- Svelte for frontend (no virtual DOM)
- Streaming responses (SSE)
- Efficient serialization

### 3. Size-Conscious

**Why:** Fast downloads, minimal storage

**How:**
- Strip debug symbols
- Link-time optimization (LTO)
- Minimal JavaScript bundle
- Compressed assets

### 4. Simplicity

**Why:** Easy to understand and maintain

**How:**
- Clear file structure
- Minimal abstractions
- Standard patterns
- Good documentation

## Directory Structure

```
llumen/
├── frontend/          # Svelte 5 SPA
│   ├── src/
│   │   ├── lib/      # Components, utilities
│   │   ├── routes/   # SvelteKit routes
│   │   └── app.html  # HTML template
│   ├── static/       # Static assets
│   └── vite.config.js
├── backend/          # Rust/Axum server
│   ├── src/
│   │   ├── main.rs   # Entry point
│   │   ├── routes/   # API routes
│   │   ├── models/   # Data structures
│   │   └── services/ # Business logic
│   └── Cargo.toml
├── agent/            # Prompts, testing
├── package/          # Build scripts
└── docs/             # This documentation
```

## Request Flow

### Normal Chat

```
1. User types message in browser
2. Frontend sends POST /api/chat
3. Backend receives request
4. Backend calls LLM API
5. Backend streams response via SSE
6. Frontend renders tokens in real-time
7. Conversation saved to disk
```

### With Web Search

```
1. User enables search mode
2. Frontend sends POST /api/chat?mode=search
3. Backend analyzes query
4. Backend searches web
5. Backend gathers context
6. Backend calls LLM with context
7. Backend streams response with sources
8. Frontend renders with citations
```

### Deep Research

```
1. User enables research mode
2. Frontend sends POST /api/chat?mode=research
3. Backend creates research plan
4. Backend executes plan steps
5. Backend streams progress updates
6. Backend synthesizes findings
7. Backend streams final report
8. Frontend shows structured results
```

## Data Flow

### User Data

```
data/
├── users/
│   └── users.db          # SQLite: users, auth
├── conversations/
│   ├── {uuid1}.json      # Conversation 1
│   ├── {uuid2}.json      # Conversation 2
│   └── ...
└── uploads/
    └── {session}/        # Temporary uploads
        └── file.pdf
```

### Conversation Format

```json
{
  "id": "uuid",
  "title": "Auto-generated title",
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:10:00Z",
  "messages": [
    {
      "role": "user",
      "content": "Hello",
      "timestamp": "2024-01-01T00:00:00Z"
    },
    {
      "role": "assistant",
      "content": "Hi! How can I help?",
      "timestamp": "2024-01-01T00:00:05Z"
    }
  ]
}
```

## API Design

### RESTful Endpoints

```
GET  /api/health              # Health check
POST /api/auth/login          # Login
POST /api/auth/logout         # Logout

GET  /api/conversations       # List conversations
GET  /api/conversations/:id   # Get conversation
POST /api/conversations       # Create conversation
DELETE /api/conversations/:id # Delete conversation

POST /api/chat                # Send message (SSE)
POST /api/upload              # Upload file
```

### Streaming Protocol

Server-Sent Events (SSE) for real-time streaming:

```
event: token
data: {"content": "Hello"}

event: token
data: {"content": " world"}

event: done
data: {"conversation_id": "uuid"}
```

## Security

### Authentication

- Session-based auth
- Secure password hashing (argon2)
- HTTP-only cookies
- CSRF protection

### Input Validation

- Request size limits
- File type validation
- SQL injection prevention (parameterized queries)
- XSS prevention (sanitized outputs)

### Resource Limits

- Max file upload: 50MB
- Max conversation length: configurable
- Request timeouts
- Rate limiting (planned)

## Performance Optimizations

### Backend

```rust
// Zero-copy JSON parsing
#[derive(Deserialize)]
struct Message<'a> {
    #[serde(borrow)]
    content: &'a str,
}

// Async streaming
async fn stream_response() -> Sse<impl Stream<Item = Event>> {
    // Stream tokens as they arrive
}

// Connection pooling (if needed)
// Minimal allocations
// Efficient error handling
```

### Frontend

```javascript
// Code splitting
const ChatView = lazy(() => import('./ChatView.svelte'));

// Reactive updates (Svelte)
$: messages = conversation.messages;

// Efficient rendering
// Minimal re-renders
// Virtual scrolling for long histories
```

## Monitoring

### Logs

Structured logging with different levels:

```rust
info!("Server started on {}", addr);
warn!("Rate limit approaching");
error!("Failed to connect to API: {}", err);
```

### Metrics (Future)

- Request latency
- Token throughput
- Error rates
- Resource usage

## Next Steps

<CardGroup cols={2}>
  <Card title="Building" href="/developer/building">
    Build llumen from source
  </Card>
  <Card title="Backend" href="/developer/backend">
    Backend development guide
  </Card>
  <Card title="Frontend" href="/developer/frontend">
    Frontend development guide
  </Card>
  <Card title="Contributing" href="/developer/contributing">
    Contribution guidelines
  </Card>
</CardGroup>
