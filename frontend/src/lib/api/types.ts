/*
 Generated by typeshare 1.13.3
*/

export enum ChatMode {
	Normal = "normal",
	Search = "search",
	Research = "research",
}

export interface ChatCreateReq {
	model_id: number;
	mode: ChatMode;
}

export interface ChatCreateResp {
	id: number;
}

export interface ChatDeleteReq {
	id: number;
}

export interface ChatDeleteResp {
	deleted: boolean;
}

export interface ChatHaltReq {
	id: number;
}

export interface ChatHaltResp {
}

export enum ChatPaginateReqOrder {
	/** greater than */
	Gt = "gt",
	/** less than */
	Lt = "lt",
}

export interface ChatPaginateReqLimit {
	/**
	 * Default to the beginning
	 * For Gt => minimum id
	 * For Le => maximum id
	 */
	id?: number;
	order: ChatPaginateReqOrder;
	limit?: number;
}

/**
 * Does not include upper & lower
 * lower [... return items ... ] upper
 */
export interface ChatPaginateReqRange {
	upper: number;
	lower: number;
}

export interface ChatPaginateRespList {
	id: number;
	model_id?: number;
	title?: string;
}

export interface ChatPaginateResp {
	list: ChatPaginateRespList[];
}

export interface ChatReadReq {
	id: number;
}

export interface ChatReadResp {
	mode: ChatMode;
	model_id?: number;
	title?: string;
}

export interface ChatUpdateReq {
	chat_id: number;
	title?: string;
}

export interface ChatUpdateResp {
	wrote: boolean;
}

export enum StepKind {
	Code = "code",
	Research = "research",
}

export type AssistantChunk = 
	| { t: "annotation", c: Value }
	| { t: "url_citation", c: UrlCitation[] }
	| { t: "text", c: string }
	| { t: "reasoning", c: string }
	| { t: "reasoning_detail", c: Value }
	| { t: "tool_call", c: {
	id: string;
	arg: string;
	name: string;
}}
	| { t: "tool_result", c: {
	id: string;
	response: string;
}}
	| { t: "error", c: string }
	| { t: "deep_agent", c: Deep }
	| { t: "image", c: number }
	| { t: "mcp_image", c: {
	data: string;
	mime_type: string;
}}
	| { t: "mcp_resource", c: {
	uri: string;
	mime_type?: string;
	text?: string;
}};

export interface Step {
	need_search: boolean;
	title: string;
	description: string;
	kind: StepKind;
	progress: AssistantChunk[];
}

export interface Deep {
	locale: string;
	has_enough_context: boolean;
	thought: string;
	title: string;
	steps: Step[];
}

/**
 * Enumeration of all possible error types in the Llumen API.
 * 
 * Each variant represents a category of error that can occur during request
 * processing. The frontend uses these to implement error-specific handling
 * (e.g., redirecting to login on Unauthorized).
 * 
 * When adding new error types:
 * 1. Consider if an existing variant applies first
 * 2. Add to the enum with a clear, descriptive name
 * 3. Update error conversion logic in route handlers
 * 4. Consider what frontend UI behavior should result from this error
 */
export enum ErrorKind {
	/**
	 * User is not authenticated or session token is missing.
	 * Frontend should redirect to login page.
	 */
	Unauthorized = "unauthorized",
	/**
	 * Session token is malformed, expired, or tampered with.
	 * Usually means the user needs to log in again.
	 */
	MalformedToken = "malformed_token",
	/**
	 * Request body doesn't match expected schema.
	 * Indicates a client-side bug or API version mismatch.
	 */
	MalformedRequest = "malformed_request",
	/**
	 * Unexpected internal server error.
	 * Indicates a bug in Llumen or an unhandled edge case.
	 * Frontend should show generic error message and suggest reporting.
	 */
	Internal = "internal",
	/**
	 * User login failed (incorrect credentials).
	 * Frontend should show specific error message to user.
	 */
	LoginFail = "login_fail",
	/**
	 * Requested resource (chat, message, user, etc.) not found.
	 * May indicate:
	 * - Resource was deleted by another client
	 * - User lacks permission to access resource
	 * - Resource ID is invalid
	 */
	ResourceNotFound = "resource_not_found",
	/**
	 * OpenRouter API request failed.
	 * Indicates network issue, rate limiting, or API problem.
	 * Frontend should suggest retrying or checking API status.
	 */
	ApiFail = "api_fail",
	/**
	 * Tool execution failed (web search, code execution, etc.).
	 * May indicate:
	 * - Network connectivity issue
	 * - Tool service is down
	 * - Tool rejected input parameters
	 * Frontend should show tool-specific error context.
	 */
	ToolCallFail = "tool_call_fail",
}

/**
 * Error response structure sent to the frontend.
 * 
 * This is the standard JSON response for all error cases.
 * The frontend uses the `error` field to determine error handling behavior,
 * and the `reason` field to display user-friendly messages.
 * 
 * # Example
 * ```json
 * {
 * "error": "unauthorized",
 * "reason": "Invalid or expired token"
 * }
 * ```
 */
export interface Error {
	/**
	 * Error classification used for client-side error handling.
	 * Determines UI behavior, logging level, and user messaging.
	 */
	error: ErrorKind;
	/**
	 * Human-readable error description from the underlying error context.
	 * Should be descriptive enough for logging but safe to show users.
	 */
	reason: string;
}

export interface FileMetadata {
	name: string;
	id: number;
}

export interface FileRefreshReq {
	ids: number[];
}

export interface FileRefreshResp {
	valid_until: number;
}

export interface FileUploadResp {
	id: number;
}

export interface HeaderAuthResp {
	token?: string;
	exp?: string;
}

export interface LoginReq {
	username: string;
	password: string;
}

export interface LoginResp {
	token: string;
	exp: string;
}

export interface McpCheckReq {
	config_raw: string;
}

export interface McpCheckResp {
	reason?: string;
}

export interface McpServerCreateReq {
	config_raw: string;
}

export interface McpServerCreateResp {
	id: number;
	name: string;
	enabled: boolean;
}

export interface McpServerDeleteReq {
	id: number;
}

export interface McpServerDeleteResp {
	deleted: boolean;
}

export interface McpServerListItem {
	id: number;
	name: string;
	enabled: boolean;
	transport: string;
	running: boolean;
	config_raw: string;
}

export interface McpServerListReq {
}

export interface McpServerListResp {
	list: McpServerListItem[];
}

export interface McpServerWriteReq {
	id: number;
	config_raw: string;
}

export interface McpServerWriteResp {
	id: number;
	name: string;
	enabled: boolean;
}

export interface MessageCreateReqFile {
	id: number;
	name: string;
}

export interface MessageCreateReq {
	chat_id: number;
	model_id: number;
	mode: ChatMode;
	text: string;
	files: MessageCreateReqFile[];
}

export interface MessageCreateResp {
	id: number;
	user_id: number;
}

export interface MessageDeleteReq {
	id: number;
}

export enum MessagePaginateReqOrder {
	/** greater than */
	Gt = "gt",
	/** less than */
	Lt = "lt",
}

export interface MessagePaginateReqLimit {
	chat_id: number;
	/** default to i32::MAX */
	id?: number;
	order: MessagePaginateReqOrder;
	limit?: number;
}

/**
 * Does not include upper & lower
 * lower [... return items ... ] upper
 */
export interface MessagePaginateReqRange {
	chat_id: number;
	upper: number;
	lower: number;
}

export type MessageInner = 
	| { t: "user", c: {
	text: string;
	files: FileMetadata[];
}}
	| { t: "assistant", c: AssistantChunk[] };

export interface MessagePaginateRespList {
	id: number;
	token_count: number;
	price: number;
	inner: MessageInner;
}

export interface MessagePaginateResp {
	list: MessagePaginateRespList[];
}

export interface ModelCheckReq {
	config: string;
}

export interface ModelCheckResp {
	reason?: string;
}

export interface ModelCreateReq {
	config: string;
}

export interface ModelCreateResp {
	id: number;
	display_name: string;
	image_input: boolean;
	audio_input: boolean;
	other_file_input: boolean;
	tool: boolean;
}

export interface ModelDeleteReq {
	id: number;
}

export interface ModelDeleteResp {
	deleted: boolean;
}

export interface ModelIdsReq {
}

export interface ModelIdsResp {
	ids: string[];
}

export interface ModelList {
	id: number;
	display_name: string;
	ocr_file_input: boolean;
	image_input: boolean;
	audio_input: boolean;
	native_file_input: boolean;
	tool: boolean;
}

export interface ModelListReq {
}

export interface ModelListResp {
	list: ModelList[];
}

export interface ModelReadReq {
	id: number;
}

export interface ModelReadResp {
	raw: string;
}

export interface ModelWriteReq {
	id: number;
	config: string;
}

export interface ModelWriteResp {
	display_name: string;
	wrote: boolean;
}

export interface RenewReq {
	token: string;
}

export interface RenewResp {
	token: string;
	exp: string;
}

export interface Resp {
	deleted: boolean;
}

export interface SseCursor {
	index: number;
	offset: number;
}

export interface SseReqResume {
	cursor: SseCursor;
	version: number;
}

export interface SseReq {
	id: number;
	resume?: SseReqResume;
}

export interface SseRespMcpImage {
	data: string;
	mime_type: string;
}

export interface SseRespMcpResource {
	uri: string;
	mime_type?: string;
	text?: string;
}

export interface SseRespMessageComplete {
	id: number;
	token_count: number;
	cost: number;
	version: number;
}

export interface SseRespToolCall {
	name: string;
	args: string;
}

export interface SseRespToolResult {
	content: string;
}

export interface SseStart {
	id: number;
	user_msg_id: number;
	version: number;
}

export interface UrlCitation {
	url: string;
	title?: string;
	content?: string;
	start_index?: number;
	end_index?: number;
	favicon?: string;
}

export interface UserCreateReq {
	username: string;
	password: string;
}

export interface UserCreateResp {
	user_id: number;
}

export interface UserDeleteReq {
	user_id: number;
}

export interface UserDeleteResp {
	deleted: boolean;
}

export interface UserList {
	id: number;
	name: string;
}

export interface UserListReq {
}

export interface UserListResp {
	list: UserList[];
}

export interface UserPreference {
	theme?: string;
	locale?: string;
	submit_on_enter?: string;
}

export interface UserReadReq {
	/** If omit will use the current user instead */
	user_id?: number;
}

export interface UserReadResp {
	user_id: number;
	username: string;
	preference: UserPreference;
}

export interface UserUpdateReq {
	/** If omit will use the current user instead */
	user_id?: number;
	preference?: UserPreference;
	password?: string;
}

export interface UserUpdateResp {
	user_id: number;
}

export type ChatPaginateReq = 
	| { t: "limit", c: ChatPaginateReqLimit }
	| { t: "range", c: ChatPaginateReqRange };

export type MessagePaginateReq = 
	| { t: "limit", c: MessagePaginateReqLimit }
	| { t: "range", c: MessagePaginateReqRange };

/**
 * Represents a message sent over the SSE (Server-Sent Events) stream in the
 * chat API.
 * 
 * Each enum variant corresponds to a specific event or data payload that can
 * be emitted to the client during a chat session. The enum is serialized in a
 * tagged form with fields `{ "t": "<variant>", "c": <content> }` (snake_case
 * variant names).
 * 
 * Concatenation semantics for assembling a complete assistant message:
 * - Assistant-generated text is streamed as a sequence of `Token(String)`
 * events.
 * - The assistant's internal reasoning is streamed as `Reasoning(String)`
 * events.
 * - In "deep" research mode, higher-level plans and final reports are streamed
 * as `DeepPlan(String)` and `DeepReport(String)` respectively, and
 * individual deep-step outputs use `DeepStep*` variants.
 * 
 * To reconstruct a full, human-facing message the client SHOULD concatenate
 * the textual chunks in the order they are received:
 * - For normal assistant responses: append `Token` chunks (and optionally
 * interleave `Reasoning` chunks if the client wants to surface reasoning).
 * When a `Complete` event arrives it indicates the assistant finished
 * producing the message and provides final metadata (message id, token
 * count, cost, version).
 * - For deep-research messages: concatenate `DeepPlan` (if any),
 * `DeepStepToken` and `DeepStepReasoning` chunks as they arrive, and finally
 * include `DeepReport` when it is emitted. `Complete` is still used to
 * indicate the message is finalized and carries the canonical metadata for
 * the completed message.
 * 
 * Other variants represent discrete non-textual events:
 * - `Version(i32)`: an initial signal of the latest message/version id for the
 * chat.
 * - `ToolCall(SseRespToolCall)`: a tool invocation with name and args.
 * - `ToolResult(SseRespToolResult)` / `DeepStepToolResult(SseRespToolResult)`:
 * tool outputs.
 * - `Start(SseStart)`: indicates the beginning of processing for a new
 * assistant message.
 * - `Title(String)`: an updated or generated title for the chat.
 * - `Error(String)`: an error message to surface to the client.
 * 
 * Important: the client should treat text-bearing variants (`Token`,
 * `Reasoning`, `DeepPlan`, `DeepStepToken`, `DeepStepReasoning`, `DeepReport`)
 * as streamable fragments that together form the final content; `Complete` is
 * the canonical signal that final assembly is complete and includes definitive
 * metadata.
 */
export type SseResp = 
	| { t: "version", c: number }
	| { t: "token", c: string }
	| { t: "reasoning", c: string }
	| { t: "tool_call", c: SseRespToolCall }
	| { t: "tool_result", c: SseRespToolResult }
	| { t: "complete", c: SseRespMessageComplete }
	| { t: "title", c: string }
	| { t: "error", c: string }
	| { t: "start", c: SseStart }
	| { t: "deep_plan", c: string }
	| { t: "deep_step_start", c: number }
	| { t: "deep_step_token", c: string }
	| { t: "deep_step_reasoning", c: string }
	| { t: "deep_step_tool_result", c: SseRespToolResult }
	| { t: "deep_step_tool_call", c: SseRespToolCall }
	| { t: "deep_report", c: string }
	| { t: "image", c: number }
	| { t: "url_citation", c: UrlCitation[] }
	| { t: "mcp_image", c: SseRespMcpImage }
	| { t: "mcp_resource", c: SseRespMcpResource };

